#!/usr/bin/env python3
# Version: 2025-10-07 16:45 Europe/Berlin
# sync-from-sheet.py – zieht ein Google-Sheet (CSV) und schreibt Hugo-Content (DE/EN)
# Zielpfade:
#   DE: wissen/content/de/oeffentlich/produkte/<slug>/index.md
#   EN: wissen/content/en/public/products/<slug>/index.md

from __future__ import annotations
import os, re, sys, unicodedata
from datetime import datetime
from io import StringIO
from pathlib import Path
from zoneinfo import ZoneInfo

import requests
import pandas as pd

# --------------------- Pfade ---------------------
ROOT   = Path(__file__).resolve().parents[1]  # .../wissen
OUT_DE = ROOT / "content" / "de" / "oeffentlich" / "produkte"
OUT_EN = ROOT / "content" / "en" / "public" / "products"

DRY_RUN = os.getenv("DRY_RUN", "") not in ("", "0", "false", "False")

# --------------------- Sanitizer -----------------
# C0: \x00-\x1F (außer \t,\n,\r schon per Normalisierung)
# C1: \x7F-\x9F  -> enthält U+0080 etc.
_BAD_CTRL_RE = re.compile(r'[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]')
_ZERO_WIDTH_RE = re.compile(r'[\u200B-\u200D\u2060]')  # Zero-widths
def sanitize_text(value: str | None) -> str:
    """Entfernt C0/C1-Steuerzeichen, NBSP/Zero-Width, repariert Encoding-Artefakte."""
    if value is None:
        return ""
    s = str(value)
    if "Ã" in s or "�" in s:
        try:
            s = s.encode("latin1", errors="ignore").decode("utf-8", errors="ignore")
        except Exception:
            pass
    s = s.replace("\r\n", "\n").replace("\r", "\n")
    s = s.replace("\u00A0", " ")           # NBSP → Space
    s = _ZERO_WIDTH_RE.sub("", s)          # Zero-widths entfernen
    s = _BAD_CTRL_RE.sub("", s)            # C0/C1 entfernen (inkl. U+0080)
    return s

def sanitize_list(vals) -> list[str]:
    if not vals:
        return []
    out = []
    for v in vals:
        t = sanitize_text(v).strip()
        if t:
            out.append(t)
    return out

# --------------------- Helpers -------------------
def now_iso_berlin() -> str:
    return datetime.now(ZoneInfo("Europe/Berlin")).replace(microsecond=0).isoformat()

def slugify(s: str) -> str:
    s = sanitize_text(s).strip().lower()
    s = unicodedata.normalize("NFKD", s)
    s = "".join(ch for ch in s if not unicodedata.combining(ch))
    s = re.sub(r"[^a-z0-9\-]+", "-", s).strip("-")
    s = re.sub(r"-{2,}", "-", s)
    return s or "item"

def split_list(val: str):
    if not val:
        return []
    parts = re.split(r"[;,]\s*", str(val).replace("\n", ","))
    return [sanitize_text(p).strip() for p in parts if sanitize_text(p).strip()]

def first_col(df: pd.DataFrame, *cands):
    lm = {c.lower(): c for c in df.columns}
    for c in cands:
        if c.lower() in lm:
            return lm[c.lower()]
    return None

def parse_varianten(row: dict):
    vy = row.get("varianten_yaml") or row.get("VARIANTEN_YAML") or ""
    if vy and str(vy).strip():
        try:
            import yaml  # optional
            v = yaml.safe_load(sanitize_text(str(vy)))
            if isinstance(v, list):
                clean = []
                for el in v:
                    if not isinstance(el, dict):
                        continue
                    clean.append({k: sanitize_text(str(vv)) for k, vv in el.items()})
                return clean
        except Exception:
            pass
    txt = row.get("varianten") or row.get("VARIANTEN") or ""
    items = []
    for chunk in split_list(txt):
        bits = [b.strip() for b in chunk.split("|")]
        if not bits or not bits[0]:
            continue
        item = {"name": sanitize_text(bits[0])}
        if len(bits) > 1 and bits[1]:
            try:
                item["preis"] = float(sanitize_text(bits[1]).replace(",", "."))
            except ValueError:
                item["preis"] = sanitize_text(bits[1])
        if len(bits) > 2 and bits[2]:
            item["einheit"] = sanitize_text(bits[2])
        if len(bits) > 3 and bits[3]:
            item["sku"] = sanitize_text(bits[3])
        items.append(item)
    return items

def yaml_block(key: str, text: str) -> str:
    safe_text = sanitize_text(text).replace("\n---", "\n—")  # verhindert Frontmatter-Abbruch in Content
    lines = [f"{key}: |"]
    for ln in safe_text.splitlines():
        lines.append(f"  {ln}")
    return "\n".join(lines)

def fm_to_str(fm: dict, title: str, beschr_de: str, beschr_en: str) -> str:
    order = [
        "title", "title_en",
        "slug", "type", "kategorie",
        "beschreibung_md_de", "beschreibung_md_en",
        "bilder", "varianten", "sku", "last_sync",
    ]
    data = {k: v for k, v in fm.items()}
    data["title"] = sanitize_text(title)
    out = ["---"]
    for k in order:
        if k == "beschreibung_md_de":
            out.append(yaml_block(k, sanitize_text(beschr_de))); continue
        if k == "beschreibung_md_en":
            out.append(yaml_block(k, sanitize_text(beschr_en))); continue
        if k not in data: continue
        v = data[k]
        if v in (None, "", []): continue
        if k in ("kategorie", "bilder"):
            arr = v if isinstance(v, list) else split_list(v)
            arr = sanitize_list(arr)
            if not arr: continue
            out.append(f"{k}:")
            for el in arr:
                out.append(f"  - {el}")
        elif k == "varianten":
            out.append("varianten:")
            for el in (v if isinstance(v, list) else []):
                out.append("  -")
                for kk, vv in el.items():
                    if vv in (None, ""): 
                        continue
                    out.append(f"    {kk}: {sanitize_text(str(vv))}")
        else:
            out.append(f"{k}: {sanitize_text(v)}")
    out.append("---")
    out.append("")  # Leerzeile hinter Frontmatter
    return "\n".join(out)

_LAST_SYNC_RE = re.compile(r'^\s*last_sync:\s*.*$', flags=re.M)
def strip_last_sync(txt: str) -> str:
    return _LAST_SYNC_RE.sub("", txt or "")

def write_product(de: dict, en: dict):
    out_de = OUT_DE / de["slug"] / "index.md"
    out_en = OUT_EN / de["slug"] / "index.md"
    out_de.parent.mkdir(parents=True, exist_ok=True)
    out_en.parent.mkdir(parents=True, exist_ok=True)

    base_fm = {
        "type": "produkte",
        "slug": sanitize_text(de["slug"]),
        "kategorie": sanitize_list(de.get("kategorie", [])),
        "bilder": sanitize_list(de.get("bilder", [])),
        "varianten": de.get("varianten", []),
        "sku": sanitize_text(de.get("sku") or en.get("sku") or ""),
    }

    fm_de_core = fm_to_str(
        {**base_fm, "title_en": sanitize_text(en["title"])},
        title=sanitize_text(de["title"]),
        beschr_de=sanitize_text(de.get("beschreibung", "")),
        beschr_en=sanitize_text(en.get("beschreibung", "")),
    )
    fm_en_core = fm_to_str(
        {**base_fm, "title_en": sanitize_text(en["title"])},
        title=sanitize_text(en["title"]),
        beschr_de=sanitize_text(de.get("beschreibung", "")),
        beschr_en=sanitize_text(en.get("beschreibung", "")),
    )

    old_de = out_de.read_text(encoding="utf-8") if out_de.exists() else ""
    old_en = out_en.read_text(encoding="utf-8") if out_en.exists() else ""
    changed_de = strip_last_sync(old_de) != strip_last_sync(fm_de_core)
    changed_en = strip_last_sync(old_en) != strip_last_sync(fm_en_core)

    wrote = False
    ts = f'last_sync: "{now_iso_berlin()}"'
    if changed_de:
        new_de = fm_de_core.rstrip() + "\n" + ts + "\n\n"
        if not DRY_RUN:
            out_de.write_text(new_de, encoding="utf-8")
        print(f"[SYNC] DE {de['slug']}: CHANGED"); wrote = True
    else:
        print(f"[SYNC] DE {de['slug']}: UNCHANGED")

    if changed_en:
        new_en = fm_en_core.rstrip() + "\n" + ts + "\n\n"
        if not DRY_RUN:
            out_en.write_text(new_en, encoding="utf-8")
        print(f"[SYNC] EN {de['slug']}: CHANGED"); wrote = True
    else:
        print(f"[SYNC] EN {de['slug']}: UNCHANGED")

    return wrote

def fetch_csv_text() -> str:
    url = (os.getenv("GSHEET_CSV_URL") or "").strip()
    if not url:
        sheet_id = (os.getenv("SHEET_ID") or os.getenv("GSHEET_ID") or "").strip()
        gid = (os.getenv("SHEET_GID") or os.getenv("GSHEET_GID") or "").strip()
        if not (sheet_id and gid):
            print("FEHLER: Setze GSHEET_CSV_URL ODER SHEET_ID+SHEET_GID.", file=sys.stderr)
            sys.exit(2)
        url = f"https://docs.google.com/spreadsheets/d/{sheet_id}/export?format=csv&gid={gid}"
    r = requests.get(url, timeout=60)
    r.raise_for_status()
    b = r.content
    if b[:3] == b'\xef\xbb\xbf':
        b = b[3:]
    txt = b.decode("utf-8", "replace")
    # CSV global sanitisieren
    txt = txt.replace("\u00A0"," ")
    txt = _ZERO_WIDTH_RE.sub("", txt)
    txt = _BAD_CTRL_RE.sub("", txt)
    return txt

def row_to_lang(row: dict, lang: str) -> dict:
    d = {k: sanitize_text(row[k]) for k in row.keys()}
    if lang == "de":
        title = d.get("titel_de") or d.get("title_de") or ""
        beschr = d.get("beschreibung_md_de") or d.get("beschreibung_de") or ""
    else:
        title = d.get("titel_en") or d.get("title_en") or ""
        beschr = d.get("beschreibung_md_en") or d.get("beschreibung_en") or ""

    slug = d.get("slug") or slugify(d.get("titel_de") or d.get("title_de") or title or "produkt")
    kat = split_list(d.get("kategorie") or d.get("category"))
    bilder = split_list(d.get("bilder") or d.get("images"))
    varianten = parse_varianten(d)
    sku = d.get("sku") or ""

    if not varianten:
        preis = d.get("preis") or ""
        einheit = d.get("einheit") or ""
        if preis or einheit or sku:
            item = {"name": "Standard"}
            if preis:
                try:
                    item["preis"] = float(preis.replace(",", "."))
                except ValueError:
                    item["preis"] = preis
            if einheit:
                item["einheit"] = einheit
            if sku:
                item["sku"] = sku
            varianten = [item]

    return {
        "slug": slug,
        "title": title,
        "beschreibung": beschr,
        "kategorie": kat,
        "bilder": bilder,
        "varianten": varianten,
        "sku": sku,
    }

def main():
    csv_text = fetch_csv_text()
    df = pd.read_csv(StringIO(csv_text))
    df = df.fillna("")
    df.columns = [c.strip() for c in df.columns]

    pub = next((c for c in df.columns if c.lower() in ("publish", "veröffentlichen")), None)
    if pub:
        df = df[df[pub].astype(str).str.lower().isin(["1", "true", "ja", "yes", "y", ""])]

    OUT_DE.mkdir(parents=True, exist_ok=True)
    OUT_EN.mkdir(parents=True, exist_ok=True)

    written = 0
    for _, row in df.iterrows():
        row = {k: row[k] for k in df.columns}
        de = row_to_lang(row, "de")
        en = row_to_lang(row, "en")
        if write_product(de, en):
            written += 1

    print(f"✓ {written} Produkte geändert (idempotent).")
    print(f"DE → {OUT_DE}")
    print(f"EN → {OUT_EN}")

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"FEHLER: {e}", file=sys.stderr)
        sys.exit(1)
